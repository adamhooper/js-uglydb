// Generated by uRequire v0.6.4 - template: 'UMDplain'
(function () {
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


(function (factory) {
  

if (typeof exports === 'object') {
   
   module.exports = factory(require, require('./StringNormalizer'), require('./ObjectNormalizer'));
 } else if (typeof define === 'function' && define.amd) {
     define(['require', './StringNormalizer', './ObjectNormalizer'], factory);
 }
}).call(this, function (require, StringNormalizer, ObjectNormalizer) {
  
// uRequire v0.6.4: START body of original AMD module
var findKeys, headerToKeyNames, isNumber, isString, keysToHeader, maybeNormalizeObjects, maybeNormalizeStrings, roundFloats, toString;
    toString = Object.prototype.toString;
    isString = function (s) {
      return toString.call(s) === "[object String]";
    };
    isNumber = function (s) {
      return toString.call(s) === "[object Number]";
    };
    findKeys = function (array) {
      var key, keys, object, value, __, _i, _j, _len, _len1;
      keys = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        for (key in object) {
          value = object[key];
          if (!(key in keys)) {
            keys[key] = 3;
          }
        }
      }
      for (key in keys) {
        __ = keys[key];
        for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
          object = array[_j];
          value = object[key];
          if (value !== null && !isString(value)) {
            keys[key] = 1;
            break;
          }
        }
      }
      return keys;
    };
    keysToHeader = function (keys) {
      var key, ret, type;
      ret = [];
      for (key in keys) {
        type = keys[key];
        ret.push(key);
        ret.push(type);
      }
      return ret;
    };
    headerToKeyNames = function (header) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = header.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(header[i * 2]);
      }
      return _results;
    };
    maybeNormalizeStrings = function (array, keys) {
      var db, key, normalizer, object, type, usefulKeys, value, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      usefulKeys = function () {
        var _results;
        _results = [];
        for (key in keys) {
          type = keys[key];
          if (type === 3) {
            _results.push(key);
          }
        }
        return _results;
      }();
      normalizer = new StringNormalizer();
      for (_i = 0, _len = usefulKeys.length; _i < _len; _i++) {
        key = usefulKeys[_i];
        for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
          object = array[_j];
          value = object[key];
          if (value != null) {
            normalizer.add(value);
          }
        }
      }
      db = normalizer.asDb();
      if (db.normalizationString != null) {
        for (_k = 0, _len2 = usefulKeys.length; _k < _len2; _k++) {
          key = usefulKeys[_k];
          for (_l = 0, _len3 = array.length; _l < _len3; _l++) {
            object = array[_l];
            object[key] = db.get(object[key]);
          }
        }
        return db.normalizationString;
      } else {
        return null;
      }
    };
    maybeNormalizeObjects = function (array, allKeys) {
      var db, key, nonStringKeys, normalizer, object, type, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      nonStringKeys = function () {
        var _results;
        _results = [];
        for (key in allKeys) {
          type = allKeys[key];
          if (type === 1) {
            _results.push(key);
          }
        }
        return _results;
      }();
      normalizer = new ObjectNormalizer();
      for (_i = 0, _len = nonStringKeys.length; _i < _len; _i++) {
        key = nonStringKeys[_i];
        for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
          object = array[_j];
          value = object[key];
          normalizer.add(key, value);
        }
      }
      db = normalizer.asDb();
      if (db.keys.length) {
        _ref = db.keys;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          key = _ref[_k];
          allKeys[key] = 2;
          for (_l = 0, _len3 = array.length; _l < _len3; _l++) {
            object = array[_l];
            object[key] = db.get(object[key]);
          }
        }
        return db.normalizationArray;
      } else {
        return null;
      }
    };
    roundFloats = function (array, keys, precision) {
      var key, object, p, type, value, _i, _len;
      p = Math.pow(10, precision);
      for (key in keys) {
        type = keys[key];
        if (type === 1) {
          for (_i = 0, _len = array.length; _i < _len; _i++) {
            object = array[_i];
            value = object[key];
            if (isNumber(value)) {
              object[key] = Math.round(value * p) / p;
            }
          }
        }
      }
      return void 0;
    };
    return function (array, options) {
      var headerArray, key, keys, keysList, normalizationArray, normalizationString, object, records, ret, _i, _j, _len, _len1;
      if (!Array.isArray(array) || !array.every(function (o) {
          return o === Object(o) && !Array.isArray(o);
        })) {
        throw "UglyDB can only encode an Array of homogeneous Objects";
      }
      array = JSON.parse(JSON.stringify(array));
      keys = findKeys(array);
      normalizationString = maybeNormalizeStrings(array, keys);
      if ((options != null ? options.precision : void 0) != null) {
        roundFloats(array, keys, options.precision);
      }
      normalizationArray = maybeNormalizeObjects(array, keys);
      headerArray = keysToHeader(keys);
      keysList = headerToKeyNames(headerArray);
      records = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        for (_j = 0, _len1 = keysList.length; _j < _len1; _j++) {
          key = keysList[_j];
          records.push(object[key]);
        }
      }
      ret = [
        "http://git.io/uglydb-0.1",
        headerArray,
        records
      ];
      if (normalizationString != null) {
        ret.push(normalizationString);
      }
      if (normalizationArray != null) {
        ret.push(normalizationArray);
      }
      return ret;
    };
// uRequire v0.6.4: END body of original AMD module


})
}).call(this);